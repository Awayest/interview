![计算机网络面试题汇总](https://guizimo.oss-cn-shanghai.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.png)



## 1、HTTP协议

### 1.1、常见的HTTP请求头和响应头

`HTTP`请求头和响应头是`HTTP`协议中的重要部分，它们包含了一些元数据，用于描述请求和响应的信息。常见的`HTTP`请求头和响应头如下：

1. **请求头**

- `Accept`：指定客户端能够接收的内容类型；
- `Accept-Encoding`：指定客户端能够接收的内容编码方式；
- `Accept-Language`：指定客户端能够接收的语言类型；
- `Cache-Control`：指定请求和响应的缓存机制； 
- `Connection`：指定客户端与服务器之间连接的类型；
- `User-Agent`：指定客户端的浏览器类型和版本号；
- `Referer`：指定从哪个页面跳转过来的；
- `Host`：指定请求的服务器域名和端口号；
- `Cookie`：指定客户端的Cookie信息；
- `Authorization`：指定客户端的身份认证信息；

2. **响应头**

- `Content-Type`：指定响应的内容类型；
- `Content-Encoding`：指定响应的内容编码方式；
- `Content-Language`：指定响应的语言类型；
- `Cache-Control`：指定请求和响应的缓存机制；
- `Server`：指定响应的服务器类型和版本号；
- `Set-Cookie`：指定响应的Cookie信息；
- `Content-Length`：指定响应内容的长度；
- `Date`：指定响应的时间戳；
- `ETag`：指定响应内容的标识符；
- `Last-Modified`：指定响应内容的最后修改时间；
- `Location`：指定响应的跳转地址；
- `Access-Control-Allow-Origin`：指定允许跨域请求的域名；

这些`HTTP`请求头和响应头是`HTTP`协议中常见的，它们可以用于描述请求和响应的信息，从而实现更加精细化的控制和管理。在实际开发中，需要根据具体的需求选择合适的`HTTP`请求头和响应头。

### 1.2、常见的Content-Type属性值

`Content-Type`指定了请求的内容类型，它是`HTTP`协议中的一个重要的标识。常见的`Content-Type`值如下：

1. **application/x-www-form-urlencoded**

   指定请求内容为表单格式，常用于提交表单数据。

2. **multipart/form-data**

   指定请求内容为多部分表单格式，常用于上传文件。

3. **application/json**

   指定请求内容为`JSON`格式，常用于`API`接口的请求。

4. **text/plain**

   指定请求内容为纯文本格式，常用于发送文本数据。

5. **application/octet-stream**

   指定请求内容为二进制流格式，常用于上传文件。

6. **application/xml**

   指定请求内容为`XML`格式，常用于`API`接口的请求。

这些`Content-Type`值是`HTTP`协议中常见的，它们可以用于描述请求的内容类型，从而帮助服务器正确地解析请求内容。在实际开发中，需要根据具体的需求和场景选择合适的`Content-Type`值。

### 1.3、常见的HTTP请求方法

`HTTP`协议定义了多种请求方法，常见的HTTP请求方法如下：

1. **GET**

   `GET`请求用于获取资源，例如获取网页、图片等。`GET`请求的特点是请求参数在`URL`中传递，通常不会对服务器上的数据进行修改。

2. **POST**

   `POST`请求用于向服务器提交数据，例如提交表单数据、上传文件等。`POST`请求的特点是请求参数在请求体中传递，通常会对服务器上的数据进行修改。

3. **PUT**

   `PUT`请求用于向服务器上传文件或者更新资源。`PUT`请求的特点是要求完全替换掉服务器上的资源，不支持部分更新。

4. **DELETE**

   `DELETE`请求用于删除服务器上的资源。`DELETE`请求的特点是要求服务器删除指定的资源。

5. **OPTIONS**

   `OPTIONS`请求用于查询服务器支持的`HTTP`请求方法。`OPTIONS`请求的特点是不会修改服务器上的资源，只是查询服务器的状态信息。

6. **HEAD**

   `HEAD`请求用于查询服务器上的资源信息，例如查询文件大小、修改时间等。`HEAD`请求的特点是只返回响应头，不返回响应体，可以用于节省网络带宽。

7. **CONNECT**

   `CONNECT`请求要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；

8. **TRACE**

   `CONNECT`请求回显服务器收到的请求，主要⽤于测试或诊断。

这些`HTTP`请求方法是`HTTP`协议中常见的，它们可以用于不同的场景和需求。在实际开发中，需要根据具体的需求选择合适的`HTTP`请求方法。

### 1.4、GET和POST的请求的区别

`GET`和`POST`是`HTTP`协议中常见的两种请求方法，它们有以下不同点：

1. **数据传输方式**

   `GET`请求是通过`URL`传递参数，而`POST`请求是通过请求体传递参数。具体来说，GET请求将参数拼接在URL后面，而POST请求将参数放在请求体中。

2. **请求长度限制**

   由于`GET`请求是通过`URL`传递参数，`URL`的长度是有限制的，通常为`2048`个字符。因此，`GET`请求传递的参数长度有限制；而`POST`请求是将参数放在请求体中传递，没有长度限制。

3. **安全性**

   由于`GET`请求将参数暴露在`URL`中，因此不适合传输敏感信息，例如密码等；而`POST`请求将参数放在请求体中，相对安全一些。

4. **缓存机制**

   由于`GET`请求是通过`URL`传递参数，可以被浏览器缓存，因此可以提高页面的加载速度；而`POST`请求不会被浏览器缓存，每次都会重新请求。

5. **幂等性**

   `GET`请求是幂等的，即多次请求同一个`URL`的结果是相同的，不会对服务器造成影响；而`POST`请求不是幂等的，即多次请求同一个`URL`的结果可能会不同。

综上所述，`GET`请求比`POST`请求更适合用于获取数据，而`POST`请求比`GET`请求更适合用于提交数据。在实际开发中，需要根据具体的需求选择合适的请求方法。

### 1.5、OPTIONS请求方法及使用场景

`OPTIONS`是一种`HTTP`请求方法，用于请求目标资源支持的`HTTP`方法、`CORS`（跨域资源共享）相关信息以及服务器支持的其他选项。当客户端想要确定资源支持哪些请求方法时，可以使用`OPTIONS`方法。

`OPTIONS`请求方法的使用场景包括：

1. **确定服务器支持的HTTP方法**：当客户端想要访问一个资源时，可以使用`OPTIONS`方法来确定服务器支持哪些`HTTP`方法。服务器会在响应中返回支持的`HTTP`方法，客户端可以根据这些信息来选择合适的`HTTP`方法进行访问。
2. **CORS预检请求**：当客户端想要进行跨域请求时，需要先进行`CORS`预检请求。这个预检请求就是使用`OPTIONS`方法发出的，用于询问服务器是否允许跨域请求。
3. **确定资源是否存在**：有时候客户端需要确定一个资源是否存在，可以使用`OPTIONS`方法来尝试请求该资源。如果服务器返回`200` `OK`状态码，则表示该资源存在。
4. **获取资源的元数据信息**：客户端可以使用`OPTIONS`方法来获取资源的元数据信息，例如资源的大小、类型、创建日期等信息。服务器会在响应中返回这些元数据信息，客户端可以据此来了解资源的详细信息。

需要注意的是，`OPTIONS`方法不会对目标资源进行实际的请求，它只是询问资源支持的`HTTP`方法和其他选项。服务器会在响应中返回支持的选项，客户端可以根据这些信息来进行后续的请求操作。

### 1.6、HTTP 1.0、HTTP 1.1 、HTTP 2.0之间有哪些区别

`HTTP 1.0`、`HTTP 1.1`和`HTTP 2.0`是`HTTP`协议的不同版本，它们之间有以下几个区别：

1. **连接复用**：`HTTP 1.0`每次请求都需要创建一个新的`TCP连接`，而`HTTP 1.1`引入了**持久连接（keep-alive）**，可以在一个`TCP连接`上发送多个请求和响应。`HTTP 2.0`更进一步引入了**多路复用**，允许在一个`TCP连接`上**并行发送多个请求和响应**，提高了性能。
2. **请求头压缩**：`HTTP 1.0`和`HTTP 1.1`的请求头不进行压缩，导致请求头占用了很多带宽。`HTTP 2.0`使用了**HPACK算法**对请求头进行压缩，减少了请求头的大小，提高了传输效率。
3. **二进制协议**：`HTTP 1.0`和`HTTP 1.1`使用**ASCII文本格式进行通信**，而`HTTP 2.0`使用了**二进制格式**，减少了数据传输的大小，提高了传输效率。
4. **流控制**：`HTTP 2.0`支持流控制，可以控制每个流的传输速率，避免了网络拥塞。
5. **服务器推送**：`HTTP 2.0`支持服务器推送，可以在客户端请求前就主动将相关资源推送给客户端，提高了性能。
6. **安全性**：`HTTP 1.0`和`HTTP 1.1`的安全性较差，需要通过`HTTPS`等方式来提高安全性。而`HTTP 2.0`要求**使用TLS加密**，提高了安全性。

总的来说，`HTTP 2.0`相比于`HTTP 1.0`和`HTTP 1.1`在性能、安全性等方面有了很大的提升。但是需要注意的是，`HTTP 2.0`并不是所有场景下都比`HTTP 1.1`更快，对于**小文件或者带宽较低**的场景，`HTTP 1.1`可能更加适合。

### 1.7、说一下HTTP 3.0

`HTTP 3.0`是`HTTP协议`的最新版本，也称为“**HTTP over QUIC**”，在传输层使用了**QUIC（Quick UDP Internet Connections）协议**，是一种基于**UDP协议的高性能传输协议**。`HTTP 3.0`与以往的`HTTP协议`相比，有以下几个主要的不同点：

1. **传输层使用QUIC**：`HTTP 3.0`使用`QUIC`作为传输层协议，相比于`TCP协议`，`QUIC`具有更好的传输性能和安全性，可以**更好地应对网络延迟和丢包等问题**。
2. **头部压缩**：`HTTP 3.0`采用了与`HTTP 2.0`相同的头部压缩技术，可以减少请求头的大小，提高传输效率。
3. **多路复用**：`HTTP 3.0`支持多路复用，可以在一个连接上并发地传输多个请求和响应，提高了传输效率。
4. **0-RTT连接**：`HTTP 3.0`支持**0-RTT（Zero Round Trip Time）连接**，可以在客户端和服务器之间建立连接时避免握手延迟，提高了连接建立速度。
5. **安全性**：`HTTP 3.0`要求使用加密的传输，可以提高传输的安全性，防止数据被窃取或篡改。

需要注意的是，`HTTP 3.0`目前还处于实验阶段，尚未被广泛应用。虽然`HTTP 3.0`具有很多优点，但是在某些情况下，如网络环境较差或者服务器不支持`QUIC协议`，`HTTP 3.0`的性能可能不如`HTTP 2.0`或者`HTTP 1.1`。因此，在选择使用哪个版本的`HTTP协议`时，需要根据具体的场景和需求来进行选择。

### 1.8、HTTP的状态码

`HTTP状态码`是在客户端和服务器之间进行通信时，用于表示请求的处理结果的三位数字代码。状态码由服务器发送到客户端，用于指示客户端如何处理请求。以下是常见的HTTP状态码及其含义：

1. **1xx（信息提示）**：服务器收到请求，需要进一步操作才能完成请求。

- 100（继续）：客户端应继续其请求。
- 101（切换协议）：服务器将遵从客户端的请求，切换到另外一个协议。

2. **2xx（成功）**：请求已成功处理。

- 200（成功）：请求已成功处理。
- 201（已创建）：请求已经被实现，资源已经被创建。
- 204（无内容）：服务器成功处理了请求，但是没有返回任何内容。
- 205（重置内容）：表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容。
- 206（部分内容）：进行范围请求。

3. **3xx（重定向）**：需要进一步的操作以完成请求。

- 301（永久移动）：请求的资源已被永久移动到新的URI。
- 302（临时移动）：请求的资源已被临时移动到新的URI。
- 303（临时移动）：表示资源存在着另一个 URL，应使用 GET 方法获取资源。
- 304（未修改）：请求的资源没有被修改，可以直接使用缓存的版本。
- 307（临时移动）：临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。

4. **4xx（客户端错误）**：请求包含语法错误或无法完成请求。

- 400（错误请求）：服务器无法理解请求的格式，可能是语法错误。
- 401（未授权）：请求需要身份验证。
- 403（禁止访问）：服务器拒绝请求。
- 404（未找到）：服务器找不到请求的资源。

5. **5xx（服务器错误）**：服务器在处理请求时发生错误。

- 500（服务器内部错误）：服务器在处理请求时发生错误。
- 501（没有实现）：表示服务器不支持当前请求所需要的某个功能。
- 503（服务不可用）：服务器当前无法处理请求，可能是由于维护或过载。

### 1.9、同样是重定向，307，303，302的区别

1. `302`是`http1.0`的协议状态码，在`http1.1`版本的时候为了细化`302`状态码⼜出来了两个状态码：`303`和`307`。 
2. `303`明确表示客户端应当采⽤**get⽅法获取资源**，它会把`POST请求`变为`GET请求`进⾏重定向。 
3. `307`会遵照浏览器标准，不会从`POST请求`变为`GET请求`。

### 1.10、HTTP协议的缓存机制是什么

`HTTP协议`的缓存机制是指客户端在请求`Web资源`时，在本地缓存中保存一份该资源的副本，下次请求时直接从本地缓存中获取，从而避免了不必要的网络请求。

`HTTP协议`定义了多种缓存控制指令，如`Cache-Control`、`Expires`、`Last-Modified`、`ETag`等，用于控制缓存的行为。

### 1.11、对Keep-Alive的理解

`Keep-Alive`是`HTTP协议`中的一个头部字段，用于指示客户端和服务器之间的连接**是否需要保持持久性**。当`Keep-Aliv`e被设置为`"true"`时，表示客户端和服务器之间的连接可以保持持久性，即`HTTP`连接可以被重复利用，而不必重新建立连接。

在`HTTP/1.1`中，`Keep-Alive`被默认开启，而在`HTTP/1.0`中是默认关闭的。通过使用`Keep-Alive`，可以**减少HTTP连接的建立和关闭所带来的开销**，从而提高HTTP连接的效率和性能。

`Keep-Alive`的工作原理是，当客户端向服务器发送`HTTP`请求时，请求头部中会包含`"Connection: Keep-Alive"`字段，表示客户端希望保持持久性连接。服务器在接收到请求后，会在响应头部中包含`"Connection: Keep-Alive"`字段，表示服务器也希望保持持久性连接。客户端在接收到响应后，会继续使用同一个`TCP`连接发送下一个`HTTP`请求，从而实现`HTTP`连接的重复利用。

除了`Keep-Alive`之外，`HTTP/1.1`还引入了另外一个头部字段`"Connection: close"`，用于指示客户端和服务器之间的连接需要在每个请求和响应之后关闭。这个头部字段可以用于主动关闭HTTP连接，或者在出现错误时关闭`HTTP`连接。

总之，`Keep-Alive`是一种用于提高`HTTP`连接效率和性能的机制，可以减少`HTTP`连接的建立和关闭所带来的开销，从而提高`HTTP`连接的重复利用率和响应速度。

### 1.12、在页面有多张图片时，HTTP是如何的加载的

- 在`HTTP 1`下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用**多域名部署**解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
- 在`HTTP 2`下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。

## 2、HTTPS

### 2.1、HTTP和HTTPS协议的区别

`HTTP（HyperText Transfer Protocol）`和`HTTPS（HTTP Secure）`是两种不同的协议，它们在数据传输和安全性方面有以下几个主要的区别：

1. **数据传输方式不同**：`HTTP`使用明文传输数据，而`HTTPS`使用`SSL/TLS`加密传输数据，可以保证数据的机密性和完整性。
2. **端口不同**：`HTTP`默认使用端口`80`进行通信，而`HTTPS`默认使用端口`443`进行通信。
3. **安全性不同**：由于`HTTP`使用**明文传输**数据，因此数据容易被窃听、篡改或者伪造。而`HTTPS`使用`SSL/TLS`加密传输数据，可以保证数据的安全性，防止数据被窃听、篡改或者伪造。
4. **证书和身份验证**：`HTTPS`需要使用`SSL/TLS证书`对服务器进行身份验证，确保客户端与服务器之间的通信是安全可信的。
5. **性能开销**：`HTTPS`需要**进行加密和解密操作**，因此会造成一定的性能开销，比`HTTP`慢一些。

总的来说，`HTTPS`相比于`HTTP`在数据传输和安全性方面有更高的要求和保障，可以保证数据的机密性、完整性和真实性，防止数据被窃听、篡改或者伪造。但是`HTTPS`相比于`HTTP`会增加一定的性能开销，需要进行加密和解密操作，因此在一些对性能要求较高的场景下，可能需要权衡考虑。

### 2.2、HTTPS通信（握手）过程

`HTTPS`的通信过程如下：

1. **客户端向服务器发起请求**，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. **服务器端接收到请求后，确认双方使用的加密方法**、并给出服务器的证书、以及一个服务器生成的随机数。
3. **客户端确认服务器证书有效后**，生成一个新的随机数，并**使用数字证书中的公钥，加密这个随机数**，然后发给服务器。并且还会提供一个前面所有内容的 `hash`的值，用来供服务器检验。
4. **服务器使用自己的私钥，来解密客户端发送过来的随机数**。并提供前面所有内容的`hash`值来供客户端检验。
5. **客户端和服务器端根据约定的加密方法使用前面的三个随机数**，**生成对话秘钥**，以后的对话过程都使用这个秘钥来加密信息。

### 2.3、HTTPS是如何保证安全的

`HTTPS（HTTP Secure）`通过使用`SSL/TLS协议`来保证通信的安全性，具体来说，`HTTPS`采用了以下几种安全措施：

1. **数据加密**：`HTTPS`使用`SSL/TLS协议`对传输的数据进行加密，确保传输的数据不会被窃听、篡改或者伪造。`SSL/TLS`协议采用对称加密和非对称加密相结合的方式来保证数据的机密性和完整性。
2. **服务器身份验证**：`HTTPS`使用`SSL/TLS证书`对服务器进行身份验证，确保客户端与服务器之间的通信是安全可信的。`SSL/TLS证书`由证书颁发机构`（CA）`颁发，可以防止中间人攻击`（Man-in-the-middle attack）`。
3. **客户端身份验证（可选**）：`HTTPS`可以使用`SSL/TLS证书`对客户端进行身份验证，确保服务器只与合法的客户端进行通信。客户端身份验证一般用于网银、电商等对安全性要求较高的场景。
4. **安全协议版本**：`HTTPS`采用的`SSL/TLS协议`支持多个版本，包括`SSL 2.0`、`SSL 3.0`、`TLS 1.0`、`TLS 1.1`、`TLS 1.2`和`TLS 1.3`等，其中`TLS 1.2`和`TLS 1.3`是目前最常用的版本。这些协议版本都有较高的安全性和加密强度，可以保证通信的安全性。
5. **安全头部**：`HTTPS`在`HTTP协议`的基础上增加了一些安全头部，包括`Strict-Transport-Security（STS）`、`X-XSS-Protection、X-Content-Type-Option`s等，可以提高通信的安全性和可信度。

综上所述，`HTTPS`通过使用`SSL/TLS`协议、服务器身份验证、数据加密、安全协议版本和安全头部等多种安全措施来保证通信的安全性，防止数据被窃听、篡改或者伪造。但是需要注意的是，`HTTPS`并不能完全保证通信的安全，仍然存在一些安全风险，如**中间人攻击**、**SSL/TLS漏洞**等，因此需要不断更新和加强安全性措施来提高通信的安全性。

### 2.4、HTTPS的优点和缺点

`HTTPS（HTTP Secure）`采用了`SSL/TLS协议`对传输的数据进行加密，可以保证通信的安全性，具有以下优点：

1. **数据安全性**：`HTTPS`可以保证数据的机密性、完整性和真实性，防止数据被窃听、篡改或者伪造。
2. **身份验证**：`HTTPS`使用`SSL/TLS证书`对服务器进行身份验证，可以确保客户端与服务器之间的通信是安全可信的。
3. **信任度高**：`HTTPS`使用`SSL/TLS证书`由证书颁发机构`（CA）`颁发，可以防止中间人攻击，提高通信的可信度。
4. **支持多种安全协议**：`HTTPS`支持多种安全协议版本，可以根据具体的需求和场景来进行选择。
5. **SEO优化**：`Google`等搜索引擎将`HTTPS`作为`SEO排名`的权重因素之一，使用`HTTPS`可以提高网站的`SEO排名`。

但是`HTTPS`也存在一些缺点：

1. **性能开销**：`HTTPS`需要进行加密和解密操作，因此会造成一定的性能开销，比`HTTP`慢一些。
2. **证书费用**：`HTTPS`使用`SSL/TLS`证书进行服务器身份验证，一般需要购买证书，可能会增加一定的成本。
3. **部署复杂**：`HTTPS`部署相对于`HTTP`更加复杂，需要进行`SSL/TLS`证书的安装和配置等操作，需要一定的技术水平。
4. **可扩展性差**：`HTTPS`使用`TCP连接`，每个连接只能处理一个请求和响应，不利于扩展和负载均衡。

需要根据具体的场景和需求来选择使用`HTTP`还是`HTTPS协议`。如果涉及到用户隐私、金融交易等对安全性要求较高的场景，建议使用`HTTPS协议`保证通信的安全性；如果只是传输一些无关紧要的信息，可以使用`HTTP协议`进行通信。

## 3、DNS协议

### 3.1、DNS协议是什么

`DNS（Domain Name System）协议`是用于**解析域名和IP地址之间映射关系**的协议。

它通过将**域名解析为IP地址**，使得用户可以使用易记的域名访问`Web资源`，而不必记忆复杂的`IP地址`。

### 3.2、DNS协议的工作原理是什么

1. **DNS查询**：当用户输入一个域名后，客户端会向`本地DNS服务器`发送一个`DNS查询请求`。
2. **递归查询**：如果`本地DNS服务器`没有缓存该域名的解析结果，它会向`根域名服务器`发送一个**递归查询请求**，从而**获得域名对应的顶级域名服务器**。
3. **迭代查询**：`本地DNS服务器`将向`顶级域名服务器`发送一个**迭代查询请求**，从而**获取下一级域名服务器的IP地址**。
4. **解析域名**：`本地DNS服务器`将向下一级域名服务器发送一个`迭代查询请求`，获取**域名的IP地址**，**并将结果缓存到本地缓存中**。
5. **返回结果**：`本地DNS服务器`将`IP地址`返回给客户端，客户端可以使用该`IP地址`访问`Web资源`。

### 3.3、DNS的迭代查询与递归查询

实际上，`DNS解析`是一个包含`迭代查询`和`递归查询`的过程。

- **递归查询**：指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。
- **迭代查询**：指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求。

一般我们向`本地DNS服务器`发送请求的方式就是**递归查询**，因为我们只需要发出一次请求，然后`本地DNS服务器`返回给我们最终的请求结果。而`本地DNS服务器`向`其他域名服务器`请求的过程是**迭代查询**的过程，因为每一次域名服务器只返回**单次查询的结果**，下一级的查询由**本地DNS服务器自己进行**。

### 3.4、DNS会同时使用TCP和UDP协议

当`DNS查询`的响应数据超过了`UDP协议`的**最大数据包大小（通常是512字节）**，或者**查询需要进行数据的传输和确认**，`DNS协议`就会使用`TCP协议`。此外，`DNS协议`中的一些特殊操作，如`DNS转发`和`AXFR（Zone Transfer）`操作，也需要使用`TCP协议`。因此，`DNS协议`可以根据具体的需求灵活地选择使用`TCP`或`UDP协议`，以实现高效、可靠的域名解析服务。

### 3.5、DNS协议的安全问题是什么

`DNS协议`存在多种安全问题，如**DNS欺骗**、**DNS劫持**、**DNS缓存投毒**等。

这些攻击方式都是通过篡改`DNS域名解析结果`来诱导用户访问假的`Web资源`，从而窃取用户的隐私信息或者造成其他安全风险。为了保障`DNS协议`的安全性，需要采取一系列措施，如使用加密传输、使用防火墙、进行监控和审计等。

## 4、网络模型

### 4.1、OSI七层模型

`OSI（Open Systems Interconnection）`七层模型是一种标准化的网络协议参考模型，用于描述计算机网络中的通信过程。以下是`OSI七层模型`的每一层及其功能：

1. **物理层（Physical Layer）**：该层的功能是定义物理介质、电信号和物理连接方式等，以实现数据的传输。
2. **数据链路层（Data Link Layer）**：该层的功能是将物理层传输的数据进行分帧、差错检测和纠错等操作，以实现可靠的数据传输。
3. **网络层（Network Layer）**：该层的功能是实现不同网络之间的互联和数据路由，以实现数据的跨网络传输。
4. **传输层（Transport Layer）**：该层的功能是为应用层提供端到端的可靠数据传输服务，包括数据分段、流量控制、拥塞控制等操作。
5. **会话层（Session Layer）**：该层的功能是建立、管理和终止应用程序之间的通信会话，以实现数据的交换和同步。
6. **表示层（Presentation Layer）**：该层的功能是将应用层数据转换为网络可识别的格式，并进行加密、压缩和解压缩等操作，以实现数据的安全传输和兼容性。
7. **应用层（Application Layer）**：该层的功能是为用户提供各种网络应用服务，如电子邮件、文件传输、`Web`浏览等，以实现用户的需求。

`OSI七层模型`为网络协议的设计和实现提供了一种标准化的参考模型，可以帮助开发人员更好地理解网络协议的工作原理，优化网络协议的性能和可靠性。

### 4.2、TCP/IP五层协议

`TCP/IP五层协议`是一种常用的网络协议层次结构，用于描述计算机网络中的通信过程。以下是`TCP/IP五层协议`的每一层及其功能：

1. **应用层（Application Layer）**：该层的功能是为用户提供各种网络应用服务，如电子邮件、文件传输、`Web浏览`等，以实现用户的需求。该层所使用的协议有`HTTP`、`FTP`、`SMTP`等。
2. **传输层（Transport Layer）**：该层的功能是为应用层提供端到端的可靠数据传输服务，包括数据分段、流量控制、拥塞控制等操作。该层所使用的协议有`TCP`、`UDP`等。
3. **网络层（Internet Layer）**：该层的功能是实现不同网络之间的互联和数据路由，以实现数据的跨网络传输。该层所使用的协议有`IP`、`ICMP`等。
4. **数据链路层（Link Layer）**：该层的功能是将网络层的数据帧封装成数据包，进行物理传输，并进行差错检测和纠错等操作，以实现可靠的数据传输。该层所使用的协议有`Ethernet`、`ARP`等。
5. **物理层（Physical Layer）**：该层的功能是定义物理介质、电信号和物理连接方式等，以实现数据的传输。该层所使用的协议有`RS-232`、`V.35`等。

`TCP/IP五层协议`是`TCP/IP协议族`的核心，为网络协议的设计和实现提供了一种标准化的参考模型，可以帮助开发人员更好地理解网络协议的工作原理，优化网络协议的性能和可靠性。

## 5、TCP与UDP

### 5.1、TCP和UDP是什么

`TCP`和`UDP`是两种常见的网络传输协议。

- **TCP**：是一种**可靠的、面向连接**的协议，它提供数据分段、流量控制、拥塞控制和错误恢复等功能，以确保数据的可靠传输。
- **UDP**：是一种**不可靠的、无连接**的协议，它提供数据包的传输功能，但不保证数据的可靠性和顺序性。

### 5.2、TCP和UDP的区别是什么

`TCP`和`UDP`的主要区别包括以下几个方面：

- **连接方式**：`TCP`是面向连接的协议，需要在通信前先建立连接；`UDP`是无连接的协议，通信前不需要建立连接。
- **数据传输方式**：`TCP`提供数据流传输，以确保数据的可靠传输和顺序性；`UDP`提供数据包传输，不保证数据的可靠性和顺序性。
- **数据传输效率**：`TCP`的数据传输效率较低，因为需要进行连接建立、数据分段、流量控制、拥塞控制和错误恢复等操作；`UDP`的数据传输效率较高，因为不需要进行这些操作。
- **应用场景**：`TCP`通常用于对数据可靠性和顺序性要求较高的应用，如`Web`、邮件、`FTP`等；`UDP`通常用于对传输效率要求较高的应用，如视频、游戏等。

### 5.3、UDP协议为什么不可靠

`UDP`在传输数据之前不需要先建立连接，具有以下的特点：

- **不保证消息交付**：不确认，不重传，无超时
- **不保证交付顺序**：不设置包序号，不重排，不会发生队首阻塞
- **不跟踪连接状态**：不必建立连接或重启状态机
- **不进行拥塞控制**：不内置客户端或网络反馈机制

### 5.4、UDP的优点和缺点是什么

- `UDP`的优点：包括**传输效率高**、**实时性好**、**网络开销低**等；

- `UDP`的缺点：包括**数据可靠性差**、**顺序性不确定**、**容易受到攻击**等。

`UDP`通常适用于对实时性要求较高、对数据可靠性和顺序性要求较低的应用场景，如视频、音频、游戏等

### 5.5、TCP和UDP的应用场景有哪些

`TCP`和`UDP`的应用场景主要取决于对数据可靠性、顺序性和传输效率的要求。

- `TCP`适用于对数据可靠性和顺序性要求较高的应用场景，如`Web`、`邮件`、`FTP`、`SSH`等；
- `UDP`适用于对传输效率要求较高、对数据可靠性和顺序性要求较低的应用场景，如视频、音频、游戏等。

### 5.6、TCP的重传机制

`TCP（Transmission Control Protocol）`采用重传机制来确保数据的可靠传输。在网络传输过程中，由于网络拥塞、丢包等原因，数据包可能会丢失或损坏，为了确保数据的可靠传输，`TCP`采用了以下几种重传机制：

1. **超时重传（Timeout Retransmission）**：`TCP`发送数据包之后，会启动一个计时器，等待接收端的确认。如果在规定的时间内未收到确认，`TCP`会认为数据包已经丢失，会重新发送该数据包。
2. **快速重传（Fast Retransmission）**：`TCP`接收到三个重复的确认（即接收端收到了同一个数据包），会认为该数据包已经丢失，会立即重传该数据包，而不是等待超时重传计时器的触发。
3. **选择性重传（Selective Retransmission）**：`TCP`在发送数据包时，会对每个数据包进行编号。如果接收端收到的数据包不连续或有丢失的数据包，会向发送端发送一个重传请求，发送端可以根据请求重传丢失的数据包，而不是重传所有数据包。

`TCP`的重传机制可以确保数据的可靠传输，但是也会带来一定的性能开销。因此，在实际应用中，需要根据网络状况和应用需求等因素，合理配置`TCP`的重传参数，以达到性能和可靠性的平衡。

### 5.7、TCP的拥塞控制机制

`TCP（Transmission Control Protocol）`的拥塞控制机制是为了避免网络的拥塞而设计的。当网络过载时，会导致数据包的丢失和延迟，从而降低网络性能和可靠性。`TCP`的拥塞控制机制可以通过限制数据包的发送速率来避免网络拥塞，具体包括以下几个方面：

1. **慢启动（Slow Start）**：`TCP`连接建立时，发送端会将发送窗口大小设为一个较小的值，然后逐渐增加发送窗口大小，以控制数据包的发送速率。在慢启动阶段，每次成功发送一个数据包后，发送窗口大小会翻倍，直到达到一个阈值。
2. **拥塞避免（Congestion Avoidance）**：当发送窗口大小达到阈值后，`TCP`进入拥塞避免阶段，此时每次成功发送一个数据包后，发送窗口大小会逐渐增加，但是增长速率会比慢启动阶段慢一些。
3. **快速重传和快速恢复（Fast Retransmit and Fast Recovery）**：当接收端连续收到三个重复的确认时，`TCP`会认为该数据包已经丢失，会立即重传该数据包，并将发送窗口大小减半，以避免网络拥塞。同时，`TCP`会进入快速恢复阶段，将发送窗口大小设为阈值的一半，然后逐渐增加发送窗口大小。
4. **超时重传（Timeout Retransmission）**：当发送端在规定的时间内未收到接收端的确认时，会认为数据包已经丢失，会重新发送该数据包，并将发送窗口大小设为一个较小的值，以避免网络拥塞。

`TCP`的拥塞控制机制可以有效避免网络拥塞，但是也会降低数据传输的速率和效率。因此，在实际应用中，需要根据网络状况和应用需求等因素，合理配置`TCP`的拥塞控制参数，以达到性能和可靠性的平衡。

### 5.8、TCP的可靠传输机制

`TCP（Transmission Control Protocol）`采用可靠传输机制来确保数据的可靠性，具体包括以下几个方面：

1. **序列号（Sequence Number）**：`TCP`在发送数据时，会对每个数据包进行编号，接收端根据序列号来确认接收的数据包是否连续和完整。
2. **确认应答（Acknowledgment）**：接收端收到数据包后，会向发送端发送确认应答，告知发送端已经接收到数据包。
3. **超时重传（Timeout Retransmission）**：当发送端发送数据包后，在规定的时间内未收到接收端的确认应答时，会认为数据包已经丢失，会重新发送该数据包。
4. **滑动窗口（Sliding Window）**：`TCP`采用滑动窗口机制来控制数据包的发送和接收。发送端会维护一个发送窗口，接收端会维护一个接收窗口，发送端每次发送数据包时，会将发送窗口向前滑动，发送端每次接收数据包时，会将接收窗口向前滑动，以控制数据包的发送和接收。
5. **选择性重传（Selective Retransmission）**：`TCP`在发送数据包时，会对每个数据包进行编号。如果接收端收到的数据包不连续或有丢失的数据包，会向发送端发送一个重传请求，发送端可以根据请求重传丢失的数据包，而不是重传所有数据包。
6. **流量控制（Flow Control）**：`TCP`采用流量控制机制来控制数据包的发送速率，以避免接收端接收不过来。接收端会向发送端发送一个窗口大小，表示当前可以接收的数据包数量，发送端会根据窗口大小控制数据包的发送速率。

通过以上可靠传输机制，`TCP`可以确保数据的可靠性和顺序性，但是也会带来一定的性能开销。因此，在实际应用中，需要根据网络状况和应用需求等因素，合理配置`TCP`的参数，以达到性能和可靠性的平衡。

### 5.9、TCP的三次握手

`TCP（Transmission Control Protocol）`的三次握手是建立`TCP`连接的过程，具体步骤如下：

1. **第一次握手（SYN）**：客户端向服务器发送一个`SYN（同步）`报文段，该报文段中包含一个随机的`初始序列号（ISN）`和一个`SYN标志位`，表示客户端请求建立`TCP连接`。
2. **第二次握手（SYN-ACK）**：服务器接收到客户端的`SYN报文`段后，会向客户端发送一个`SYN-ACK（同步-确认）`报文段，该报文段中包含一个`确认号（ACK）`和一个`SYN标志位`，表示服务器已经收到客户端的请求，并且确认客户端的`ISN`正确。服务器还会在该报文段中加入自己的随机序列号。
3. **第三次握手（ACK）**：客户端接收到服务器的`SYN-ACK`报文段后，会向服务器发送一个`ACK（确认）`报文段，该报文段中包含客户端的`确认号（ACK）`，表示客户端已经收到服务器的确认，并且确认服务器的序列号正确。此时`TCP`连接建立成功，可以开始进行数据传输。

三次握手的目的是确保客户端和服务器都已经准备好建立`TCP`连接，并且可以正常进行数据传输。通过三次握手，可以防止连接请求被重复传递，避免建立无效连接和资源浪费，同时也可以防止窃听者伪造连接请求。

### 5.10、TCP的四次挥手

`TCP（Transmission Control Protocol）`的四次挥手是关闭TCP连接的过程，具体步骤如下：

1. **第一次挥手（FIN）**：客户端向服务器发送一个`FIN（结束）`报文段，表示客户端已经完成数据传输，并且请求关闭`TCP连接`。
2. **第二次挥手（ACK）**：服务器接收到客户端的`FIN报文段后`，会向客户端发送一个`ACK（确认）`报文段，表示服务器已经收到客户端的请求，并且准备好关闭TCP连接。
3. **第三次挥手（FIN）**：服务器向客户端发送一个`FIN报文段`，表示服务器已经完成数据传输，并且请求关闭`TCP连接`。
4. **第四次挥手（ACK）**：客户端接收到服务器的`FIN报文段`后，会向服务器发送一个`ACK报文段`，表示客户端已经收到服务器的请求，并且准备好关闭`TCP连接`。此时`TCP连接`关闭完成。

四次挥手的目的是确保客户端和服务器都已经完成数据传输，并且可以正常`关闭TCP连接`。通过四次挥手，可以防止数据丢失和重复传输，同时也可以避免连接的不正常关闭，保证数据传输的可靠性和完整性。

### 5.11、TCP为什么要四次挥手，三次不行吗

`TCP`的四次挥手是必要的，因为在`TCP`连接的关闭过程中，双方都可能还有未传输完的数据或者未被确认的数据包，需要进行确认和传输，以确保数据传输的可靠性和完整性。

`TCP`的四次挥手是必要的，以确保双方都能正确地关闭连接，并且传输和确认所有的数据包。如果使用三次挥手，可能会导致一方还有未传输完的数据或者未被确认的数据包，从而影响数据传输的可靠性和完整性。

### 5.12、TCP粘包是怎么回事，如何处理

`TCP粘包`是指在数据传输过程中，多个数据包被合并成一个大的数据包一起发送或者一个大的数据包被拆分成多个小的数据包发送，从而导致接收端无法正确解析数据包的边界，造成数据传输的混乱和错误。

`TCP粘包`的原因主要有两个：

1. **数据包长度不确定**：`TCP`是基于字节流的协议，发送端和接收端之间没有明确的边界，数据包的长度不确定，可能会导致多个数据包合并成一个大的数据包发送，或者一个大的数据包被拆分成多个小的数据包发送。
2. **数据包发送速度不一致**：由于网络状况和数据处理能力等因素的影响，发送端和接收端之间的数据包发送速度可能不一致，从而导致多个数据包被合并成一个大的数据包发送或者一个大的数据包被拆分成多个小的数据包发送。

解决`TCP粘包`问题的方法主要有以下几种：

1. **添加消息边界**：在数据包中添加一个特殊的标识符，表示数据包的边界，接收端可以根据该标识符来分割数据包。
2. **固定长度分割**：将数据包按照固定的长度进行分割，接收端可以根据固定的长度来分割数据包。
3. **在数据包中添加长度字段**：在数据包的头部添加一个长度字段，表示数据包的长度，接收端可以根据长度字段来正确接收数据包。
4. **关闭Nagle算法**：`Nagle`算法是一种优化`TCP`传输性能的算法，但是它可能会导致`TCP粘包`问题。可以关闭`Nagle算法`来减少`TCP粘包`的发生。
5. **应用层协议处理**：在应用层协议中处理`TCP粘包`问题，例如使用`XML`、`JSON`等格式进行数据传输，并在数据包中添加特定的标识符，来分割数据包。

### 5.13、为什么udp不会粘包

`UDP（User Datagram Protocol）`协议是一种无连接的、不可靠的数据传输协议，也就是说，`UDP`不会对数据包进行分段和重组，也不会对数据包进行确认和重传。因此，`UDP协议`不存在`TCP粘包`的问题。

`UDP`在发送数据包时，将整个数据包封装在一个`UDP数据报`中，并在`UDP数据`报头部添加源端口号和目标端口号等信息，然后直接发送给接收端。接收端接收到数据包后，可以直接解析数据包，不需要像`TCP协议`那样进行数据包的分段、重组、确认和重传等操作。

由于`UDP协议`不会对数据包进行分段和重组，也不需要进行数据包的确认和重传，因此，UDP协议能够快速地传输数据包，并且具有较低的延迟和较小的网络开销，适用于实时性要求较高、数据传输量较小、容忍一定数据丢失的应用场景，如音视频传输、游戏等。

总之，`UDP协议`不会出现`TCP粘包`的问题，但是由于`UDP协议`不可靠，也容易出现数据丢失和乱序等问题，需要根据具体的应用场景和需求选择合适的协议来进行数据传输。

## 6、WebSocket

### 6.1、WebSocket是什么，有什么优点和缺点

`WebSocket`是一种基于`TCP协议`的**全双工通信协议**，它允许浏览器和服务器之间进行实时的双向数据传输，从而实现了实时通信和服务推送。`WebSocket`协议具有以下优点：

- **实时性**：`WebSocket`支持实时双向通信，可以在客户端和服务器之间实现实时数据传输，避免了`HTTP协议`的轮询和长轮询等问题。
- **简单易用**：`WebSocket`协议基于`HTTP协议`，使用简单，易于开发和维护。
- **较小的网络开销**：`WebSocket`协议使用较小的网络开销，可以减少网络带宽和服务器资源的占用。

`WebSocket`协议的缺点主要包括：

- **兼容性问题**：`WebSocket`协议需要浏览器和服务器都支持，需要考虑兼容性问题。
- **安全性问题**：`WebSocket`协议开放了全双工通信的通道，需要考虑安全性问题，避免信息泄露和攻击等问题。

### 6.2、WebSocket如何建立连接，断开连接

`WebSocket`连接的建立和断开过程包括以下几个步骤：

- **建立连接**：客户端向服务器发送`WebSocket`握手请求，请求中包含协议版本、请求头和密钥等信息。服务器接收到请求后，进行协议升级和握手确认，返回带有状态码的握手响应，表示`WebSocket`连接已经建立成功。
- **数据传输**：`WebSocket`连接建立成功后，客户端和服务器之间可以进行双向的实时数据传输。
- **断开连接**：`WebSocket`连接可以由客户端或服务器主动断开。客户端可以通过调用`close()`方法来关闭连接，服务器可以发送关闭帧来关闭连接，或者通过关闭`TCP连接`来关闭`WebSocket`连接。

### 6.3、WebSocket和HTTP的区别是什么

`WebSocket`和`HTTP协议`都是基于`TCP协议`的应用层协议，但是它们有以下区别：

- **连接方式不同**：`HTTP`协议是基于请求-响应模式的单向通信协议，每次请求需要重新建立连接；`WebSocket`协议是基于全双工通信的双向通信协议，通过一次握手建立连接后，可以实现实时的双向数据传输。
- **数据格式不同**：`HTTP`协议传输的数据格式通常是字符串或二进制流，需要通过`HTTP`头部进行标识；`WebSocket`协议传输的数据格式可以是文本或二进制流，不需要进行标识。
- **传输效率不同**：`HTTP`协议每次请求需要重新建立连接，每次连接都需要进行`TCP`三次握手和四次挥手，消耗较多的网络开销；`WebSocket`协议只需要进行一次握手，可以实现实时的双向数据传输，效率较高。
- **端口号不同**：`HTTP`协议默认使用80端口进行通信；`WebSocket`协议默认使用443端口进行加密通信，或者使用80端口进行非加密通信。

总之，`WebSocket`协议和`HTTP`协议都是基于`TCP`协议的应用层协议，但是它们的连接方式、数据格式、传输效率和端口号等方面有所不同。`WebSocket`协议适用于实时通信和服务推送等场景，而`HTTP`协议适用于传统的请求-响应模式的数据传输场景。

### 6.4、长轮询和短轮询和WebSocket的区别

`长轮询`和`短轮询`是`HTTP`协议的两种传统的客户端与服务器之间进行实时通信的方式，而`WebSocket`是一种新的全双工通信协议，可以实现实时双向数据传输，以下是它们之间的一些区别：

1. **短轮询**：短轮询是指客户端不断向服务器发送`HTTP`请求，服务器在接收到请求后立即返回响应。客户端在接收到响应后，根据响应中的数据来更新页面内容。这种方式的缺点是客户端需要不断地向服务器发送请求，会造成大量的`HTTP`请求和响应，增加了网络流量和服务器的负载。
2. **长轮询**：长轮询是指客户端向服务器发送`HTTP`请求，服务器在接收到请求后，保持连接不断开，直到有数据可用或者超时时间到达才返回响应。客户端在接收到响应后，根据响应中的数据来更新页面内容，并立即发起下一次请求。这种方式可以减少`HTTP`请求和响应的次数，但是需要服务器支持长连接，同时也会增加服务器的负载。
3. **WebSocket**：`WebSocket`是一种全双工通信协议，可以在一次握手后建立连接，实现实时双向数据传输。`WebSocket`协议可以替代短轮询和长轮询，减少`HTTP`请求和响应的次数，同时也可以实现更加实时的数据传输和更高效的网络通信。`WebSocket`协议需要浏览器和服务器都支持，但是它可以适用于更加复杂和实时的应用场景，如在线游戏、在线聊天等。

总之，短轮询和长轮询是传统的`HTTP`协议实现实时通信的方式，需要不断地发送`HTTP`请求和响应，增加了网络流量和服务器负载。`WebSocket`协议是一种新的全双工通信协议，可以实现更加实时、更高效的数据传输和网络通信，适用于更加复杂和实时的应用场景。

